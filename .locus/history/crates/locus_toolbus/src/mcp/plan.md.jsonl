{"ts":1771629796,"old":"# MCP Server Implementation Plan\n\n## Overview\n\nImplement Model Context Protocol (MCP) server support that allows users to attach external MCP servers to the locus ToolBus. Users can configure MCP servers via CLI with or without authentication.\n\n## Goals\n\n1. **Runtime MCP Server Attachment**: Allow users to attach MCP servers at runtime\n2. **Flexible Authentication**: Support both no-auth and authenticated connections\n3. **CLI Management**: Provide intuitive CLI commands for MCP server management\n4. **Tool Registration**: Automatically register MCP tools in the ToolBus\n5. **Schema Storage**: Store tool schemas in LocusGraph for discovery\n6. **Process Management**: Manage MCP server lifecycle (start, stop, restart)\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         CLI Layer                            │\n│  `locus mcp add|list|remove|start|stop|test`                │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    MCP Manager                               │\n│  - Server registry (config persistence)                      │\n│  - Process lifecycle management                              │\n│  - Connection pooling                                        │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    MCP Client                                │\n│  - JSON-RPC communication                                    │\n│  - Protocol handshake                                        │\n│  - Tool discovery                                            │\n│  - Tool invocation                                           │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    ToolBus Integration                        │\n│  - Register MCP tools as ToolBus tools                       │\n│  - Tool namespace (e.g., `mcp.filesystem_read`)              │\n│  - Schema conversion (MCP → ToolBus)                         │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Phases\n\n### Phase 1: Core MCP Client\n\n#### 1.1 MCP Protocol Types\n**File**: `crates/locus_toolbus/src/mcp/protocol.rs`\n\n```rust\n// MCP JSON-RPC types\npub struct JsonRpcRequest {\n    jsonrpc: String,\n    id: u64,\n    method: String,\n    params: serde_json::Value,\n}\n\npub struct JsonRpcResponse {\n    jsonrpc: String,\n    id: u64,\n    result: Option<serde_json::Value>,\n    error: Option<JsonRpcError>,\n}\n\n// MCP protocol messages\npub struct InitializeParams {\n    protocol_version: String,\n    capabilities: ClientCapabilities,\n    client_info: Implementation,\n}\n\npub struct InitializeResult {\n    protocol_version: String,\n    capabilities: ServerCapabilities,\n    server_info: Implementation,\n}\n\npub struct Tool {\n    name: String,\n    description: String,\n    input_schema: serde_json::Value,\n}\n```\n\n#### 1.2 MCP Client\n**File**: `crates/locus_toolbus/src/mcp/client.rs`\n\n```rust\npub struct McpClient {\n    process: Child,\n    stdin: ChildStdin,\n    stdout: BufReader<ChildStdout>,\n    request_id: AtomicU64,\n}\n\nimpl McpClient {\n    pub async fn start(config: &McpServerConfig) -> Result<Self>;\n    pub async fn initialize(&mut self) -> Result<InitializeResult>;\n    pub async fn list_tools(&mut self) -> Result<Vec<Tool>>;\n    pub async fn call_tool(&mut self, name: &str, args: Value) -> Result<Value>;\n    pub async fn shutdown(&mut self) -> Result<()>;\n}\n```\n\n### Phase 2: MCP Server Configuration\n\n#### 2.1 Configuration Schema\n**File**: `crates/locus_toolbus/src/mcp/config.rs`\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpServerConfig {\n    pub id: String,\n    pub name: String,\n    pub command: String,\n    pub args: Vec<String>,\n    pub env: HashMap<String, String>,\n    pub working_dir: Option<PathBuf>,\n    pub auth: Option<McpAuthConfig>,\n    pub auto_start: bool,\n    pub restart_policy: RestartPolicy,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpAuthConfig {\n    pub auth_type: String,  // \"bearer\", \"basic\", \"api_key\"\n    pub token: String,       // can reference env var with $VAR_NAME\n    pub header: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RestartPolicy {\n    Never,\n    OnFailure { max_retries: u32 },\n    Always,\n}\n```\n\n#### 2.2 Configuration Storage\n**File**: `~/.config/locus/mcp_servers.toml`\n\n```toml\n[[servers]]\nid = \"filesystem\"\nname = \"Filesystem MCP Server\"\ncommand = \"mcp-filesystem\"\nargs = [\"--root\", \"/home/user/projects\"]\nauto_start = true\n\n[[servers]]\nid = \"github\"\nname = \"GitHub MCP Server\"\ncommand = \"mcp-github\"\nargs = [\"--repo\", \"owner/repo\"]\nauth = { auth_type = \"bearer\", token = \"$GITHUB_TOKEN\" }\nauto_start = true\n```\n\n### Phase 3: CLI Commands\n\n#### 3.1 CLI Structure\n**File**: `crates/locus_cli/src/cli.rs`\n\nAdd to `Command` enum:\n\n```rust\n#[derive(Subcommand)]\npub enum Command {\n    // ... existing commands ...\n\n    /// Manage MCP servers\n    Mcp {\n        #[command(subcommand)]\n        action: McpAction,\n    },\n}\n\n#[derive(Subcommand)]\npub enum McpAction {\n    /// Add a new MCP server\n    Add {\n        #[arg(short, long)]\n        id: String,\n        #[arg(short, long)]\n        name: String,\n        #[arg(short, long)]\n        command: String,\n        #[arg(short, long)]\n        args: Vec<String>,\n        #[arg(short = 'e', long)]\n        env: Vec<String>,\n        #[arg(long)]\n        auth_type: Option<String>,\n        #[arg(long)]\n        auth_token: Option<String>,\n        #[arg(long)]\n        auto_start: bool,\n    },\n\n    /// List configured MCP servers\n    List { #[arg(short, long)] detailed: bool },\n\n    /// Remove an MCP server configuration\n    Remove { server_id: String },\n\n    /// Start an MCP server\n    Start { server_id: String },\n\n    /// Stop a running MCP server\n    Stop { server_id: String },\n\n    /// Test MCP server connection\n    Test { server_id: String },\n\n    /// Show MCP server details and tools\n    Info { server_id: String },\n\n    /// Call an MCP tool directly\n    Call {\n        tool: String,\n        #[arg(short, long)]\n        args: String,\n    },\n}\n```\n\n#### 3.2 CLI Implementation\n**File**: `crates/locus_cli/src/commands/mcp.rs`\n\n```rust\npub async fn handle_mcp_action(action: McpAction) -> Result<()> {\n    match action {\n        McpAction::Add { id, name, command, args, env, auth_type, auth_token, auto_start } => {\n            add_server(id, name, command, args, env, auth_type, auth_token, auto_start).await\n        }\n        McpAction::List { detailed } => list_servers(detailed).await,\n        McpAction::Remove { server_id } => remove_server(server_id).await,\n        McpAction::Start { server_id } => start_server(server_id).await,\n        McpAction::Stop { server_id } => stop_server(server_id).await,\n        McpAction::Test { server_id } => test_server(server_id).await,\n        McpAction::Info { server_id } => show_server_info(server_id).await,\n        McpAction::Call { tool, args } => call_mcp_tool(tool, args).await,\n    }\n}\n```\n\n### Phase 4: MCP Manager\n\n#### 4.1 Server Registry\n**File**: `crates/locus_toolbus/src/mcp/manager.rs`\n\n```rust\npub struct McpManager {\n    config_path: PathBuf,\n    servers: RwLock<HashMap<String, McpServerConfig>>,\n    running: RwLock<HashMap<String, McpClient>>,\n    toolbus: Arc<ToolBus>,\n}\n\nimpl McpManager {\n    pub async fn load(config_path: PathBuf) -> Result<Self>;\n    pub async fn save(&self) -> Result<()>;\n    pub async fn add_server(&self, config: McpServerConfig) -> Result<()>;\n    pub async fn remove_server(&self, id: &str) -> Result<()>;\n    pub async fn start_server(&self, id: &str) -> Result<()>;\n    pub async fn stop_server(&self, id: &str) -> Result<()>;\n    pub async fn auto_start(&self) -> Result<()>;\n    pub async fn list_servers(&self) -> Vec<McpServerConfig>;\n    pub async fn test_server(&self, id: &str) -> Result<ServerTestResult>;\n    pub async fn call_tool(&self, server_id: &str, tool_name: &str, args: Value) -> Result<Value>;\n}\n```\n\n#### 4.2 ToolBus Integration\n**File**: `crates/locus_toolbus/src/mcp/toolbus_integration.rs`\n\n```rust\npub struct McpToolWrapper {\n    server_id: String,\n    tool: Tool,\n    manager: Arc<McpManager>,\n}\n\n#[async_trait]\nimpl Tool for McpToolWrapper {\n    fn name(&self) -> &str {\n        // Format: mcp.{server_id}.{tool_name}\n        &self.tool.name\n    }\n\n    fn description(&self) -> &str {\n        &self.tool.description\n    }\n\n    fn parameters_schema(&self) -> &serde_json::Value {\n        &self.tool.input_schema\n    }\n\n    async fn call(&self, args: serde_json::Value) -> Result<serde_json::Value> {\n        self.manager.call_tool(&self.server_id, &self.tool.name, args).await\n    }\n}\n```\n\n### Phase 5: Error Handling\n\n**File**: `crates/locus_toolbus/src/mcp/error.rs`\n\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum McpError {\n    #[error(\"Server not found: {0}\")]\n    ServerNotFound(String),\n\n    #[error(\"Server already running: {0}\")]\n    ServerAlreadyRunning(String),\n\n    #[error(\"Server not running: {0}\")]\n    ServerNotRunning(String),\n\n    #[error(\"Failed to start server: {0}\")]\n    StartFailed(String),\n\n    #[error(\"JSON-RPC error: {0}\")]\n    JsonRpc(String),\n\n    #[error(\"Protocol error: {0}\")]\n    Protocol(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthFailed(String),\n\n    #[error(\"Tool not found: {0}\")]\n    ToolNotFound(String),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n```\n\n## CLI Usage Examples\n\n### Adding MCP Servers\n\n```bash\n# Add a simple MCP server (no auth)\nlocus mcp add \\\n  --id filesystem \\\n  --name \"Filesystem Server\" \\\n  --command mcp-filesystem \\\n  --args \"--root\" --args \"/home/user/projects\" \\\n  --auto-start\n\n# Add MCP server with authentication\nlocus mcp add \\\n  --id github \\\n  --name \"GitHub Server\" \\\n  --command mcp-github \\\n  --args \"--repo\" --args \"owner/repo\" \\\n  --auth-type bearer \\\n  --auth-token \"$GITHUB_TOKEN\" \\\n  --auto-start\n\n# Add with environment variables\nlocus mcp add \\\n  --id database \\\n  --name \"PostgreSQL Server\" \\\n  --command mcp-postgres \\\n  --env \"DATABASE_URL=postgresql://localhost/mydb\" \\\n  --auto-start\n```\n\n### Managing Servers\n\n```bash\nlocus mcp list\nlocus mcp list --detailed\nlocus mcp info filesystem\nlocus mcp test github\nlocus mcp start database\nlocus mcp stop filesystem\nlocus mcp remove old-server\n```\n\n### Using MCP Tools\n\n```bash\nlocus mcp call filesystem.read_file --args '{\"path\": \"/home/user/file.txt\"}'\nlocus toolbus call mcp.filesystem_read_file --args '{\"path\": \"/home/user/file.txt\"}'\n```\n\n## File Structure\n\n```\ncrates/locus_toolbus/src/mcp/\n├── mod.rs              # Module exports\n├── plan.md             # This plan\n├── protocol.rs         # MCP JSON-RPC types\n├── client.rs           # MCP client implementation\n├── config.rs           # Server configuration types\n├── manager.rs          # Server registry and lifecycle\n├── error.rs            # Error types\n└── toolbus_integration.rs  # ToolBus adapter\n```\n\n## Dependencies\n\nAdd to `crates/locus_toolbus/Cargo.toml`:\n\n```toml\n[dependencies]\ntokio = { version = \"1\", features = [\"process\", \"io-util\", \"time\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\ntoml = \"0.8\"\nthiserror = \"1\"\ntracing = \"0.1\"\nasync-trait = \"0.1\"\n```\n\n## Security Considerations\n\n1. **Token Storage**: Store auth tokens securely (consider OS keychain integration)\n2. **Process Isolation**: Run MCP servers with minimal permissions\n3. **Input Validation**: Validate all tool inputs before passing to MCP servers\n4. **Rate Limiting**: Implement rate limiting for tool calls\n5. **Audit Logging**: Log all MCP tool invocations for security auditing\n","new":"# MCP Server Implementation Plan Guide\n\n## Overview\n\nImplement Model Context Protocol (MCP) server support that allows users to attach external MCP servers to the locus ToolBus. Users can configure MCP servers via CLI with or without authentication.\n\n## Goals\n\n1. **Runtime MCP Server Attachment**: Allow users to attach MCP servers at runtime\n2. **Flexible Authentication**: Support both no-auth and authenticated connections\n3. **CLI Management**: Provide intuitive CLI commands for MCP server management\n4. **Tool Registration**: Automatically register MCP tools in the ToolBus\n5. **Schema Storage**: Store tool schemas in LocusGraph for discovery\n6. **Process Management**: Manage MCP server lifecycle (start, stop, restart)\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         CLI Layer                            │\n│  `locus mcp add|list|remove|start|stop|test`                │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    MCP Manager                               │\n│  - Server registry (config persistence)                      │\n│  - Process lifecycle management                              │\n│  - Connection pooling                                        │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    MCP Client                                │\n│  - JSON-RPC communication                                    │\n│  - Protocol handshake                                        │\n│  - Tool discovery                                            │\n│  - Tool invocation                                           │\n└────────────────────┬────────────────────────────────────────┘\n                     │\n┌────────────────────▼────────────────────────────────────────┐\n│                    ToolBus Integration                        │\n│  - Register MCP tools as ToolBus tools                       │\n│  - Tool namespace (e.g., `mcp.filesystem_read`)              │\n│  - Schema conversion (MCP → ToolBus)                         │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Implementation Phases\n\n### Phase 1: Core MCP Client\n\n#### 1.1 MCP Protocol Types\n**File**: `crates/locus_toolbus/src/mcp/protocol.rs`\n\n```rust\n// MCP JSON-RPC types\npub struct JsonRpcRequest {\n    jsonrpc: String,\n    id: u64,\n    method: String,\n    params: serde_json::Value,\n}\n\npub struct JsonRpcResponse {\n    jsonrpc: String,\n    id: u64,\n    result: Option<serde_json::Value>,\n    error: Option<JsonRpcError>,\n}\n\n// MCP protocol messages\npub struct InitializeParams {\n    protocol_version: String,\n    capabilities: ClientCapabilities,\n    client_info: Implementation,\n}\n\npub struct InitializeResult {\n    protocol_version: String,\n    capabilities: ServerCapabilities,\n    server_info: Implementation,\n}\n\npub struct Tool {\n    name: String,\n    description: String,\n    input_schema: serde_json::Value,\n}\n```\n\n#### 1.2 MCP Client\n**File**: `crates/locus_toolbus/src/mcp/client.rs`\n\n```rust\npub struct McpClient {\n    process: Child,\n    stdin: ChildStdin,\n    stdout: BufReader<ChildStdout>,\n    request_id: AtomicU64,\n}\n\nimpl McpClient {\n    pub async fn start(config: &McpServerConfig) -> Result<Self>;\n    pub async fn initialize(&mut self) -> Result<InitializeResult>;\n    pub async fn list_tools(&mut self) -> Result<Vec<Tool>>;\n    pub async fn call_tool(&mut self, name: &str, args: Value) -> Result<Value>;\n    pub async fn shutdown(&mut self) -> Result<()>;\n}\n```\n\n### Phase 2: MCP Server Configuration\n\n#### 2.1 Configuration Schema\n**File**: `crates/locus_toolbus/src/mcp/config.rs`\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpServerConfig {\n    pub id: String,\n    pub name: String,\n    pub command: String,\n    pub args: Vec<String>,\n    pub env: HashMap<String, String>,\n    pub working_dir: Option<PathBuf>,\n    pub auth: Option<McpAuthConfig>,\n    pub auto_start: bool,\n    pub restart_policy: RestartPolicy,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct McpAuthConfig {\n    pub auth_type: String,  // \"bearer\", \"basic\", \"api_key\"\n    pub token: String,       // can reference env var with $VAR_NAME\n    pub header: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum RestartPolicy {\n    Never,\n    OnFailure { max_retries: u32 },\n    Always,\n}\n```\n\n#### 2.2 Configuration Storage\n**File**: `~/.config/locus/mcp_servers.toml`\n\n```toml\n[[servers]]\nid = \"filesystem\"\nname = \"Filesystem MCP Server\"\ncommand = \"mcp-filesystem\"\nargs = [\"--root\", \"/home/user/projects\"]\nauto_start = true\n\n[[servers]]\nid = \"github\"\nname = \"GitHub MCP Server\"\ncommand = \"mcp-github\"\nargs = [\"--repo\", \"owner/repo\"]\nauth = { auth_type = \"bearer\", token = \"$GITHUB_TOKEN\" }\nauto_start = true\n```\n\n### Phase 3: CLI Commands\n\n#### 3.1 CLI Structure\n**File**: `crates/locus_cli/src/cli.rs`\n\nAdd to `Command` enum:\n\n```rust\n#[derive(Subcommand)]\npub enum Command {\n    // ... existing commands ...\n\n    /// Manage MCP servers\n    Mcp {\n        #[command(subcommand)]\n        action: McpAction,\n    },\n}\n\n#[derive(Subcommand)]\npub enum McpAction {\n    /// Add a new MCP server\n    Add {\n        #[arg(short, long)]\n        id: String,\n        #[arg(short, long)]\n        name: String,\n        #[arg(short, long)]\n        command: String,\n        #[arg(short, long)]\n        args: Vec<String>,\n        #[arg(short = 'e', long)]\n        env: Vec<String>,\n        #[arg(long)]\n        auth_type: Option<String>,\n        #[arg(long)]\n        auth_token: Option<String>,\n        #[arg(long)]\n        auto_start: bool,\n    },\n\n    /// List configured MCP servers\n    List { #[arg(short, long)] detailed: bool },\n\n    /// Remove an MCP server configuration\n    Remove { server_id: String },\n\n    /// Start an MCP server\n    Start { server_id: String },\n\n    /// Stop a running MCP server\n    Stop { server_id: String },\n\n    /// Test MCP server connection\n    Test { server_id: String },\n\n    /// Show MCP server details and tools\n    Info { server_id: String },\n\n    /// Call an MCP tool directly\n    Call {\n        tool: String,\n        #[arg(short, long)]\n        args: String,\n    },\n}\n```\n\n#### 3.2 CLI Implementation\n**File**: `crates/locus_cli/src/commands/mcp.rs`\n\n```rust\npub async fn handle_mcp_action(action: McpAction) -> Result<()> {\n    match action {\n        McpAction::Add { id, name, command, args, env, auth_type, auth_token, auto_start } => {\n            add_server(id, name, command, args, env, auth_type, auth_token, auto_start).await\n        }\n        McpAction::List { detailed } => list_servers(detailed).await,\n        McpAction::Remove { server_id } => remove_server(server_id).await,\n        McpAction::Start { server_id } => start_server(server_id).await,\n        McpAction::Stop { server_id } => stop_server(server_id).await,\n        McpAction::Test { server_id } => test_server(server_id).await,\n        McpAction::Info { server_id } => show_server_info(server_id).await,\n        McpAction::Call { tool, args } => call_mcp_tool(tool, args).await,\n    }\n}\n```\n\n### Phase 4: MCP Manager\n\n#### 4.1 Server Registry\n**File**: `crates/locus_toolbus/src/mcp/manager.rs`\n\n```rust\npub struct McpManager {\n    config_path: PathBuf,\n    servers: RwLock<HashMap<String, McpServerConfig>>,\n    running: RwLock<HashMap<String, McpClient>>,\n    toolbus: Arc<ToolBus>,\n}\n\nimpl McpManager {\n    pub async fn load(config_path: PathBuf) -> Result<Self>;\n    pub async fn save(&self) -> Result<()>;\n    pub async fn add_server(&self, config: McpServerConfig) -> Result<()>;\n    pub async fn remove_server(&self, id: &str) -> Result<()>;\n    pub async fn start_server(&self, id: &str) -> Result<()>;\n    pub async fn stop_server(&self, id: &str) -> Result<()>;\n    pub async fn auto_start(&self) -> Result<()>;\n    pub async fn list_servers(&self) -> Vec<McpServerConfig>;\n    pub async fn test_server(&self, id: &str) -> Result<ServerTestResult>;\n    pub async fn call_tool(&self, server_id: &str, tool_name: &str, args: Value) -> Result<Value>;\n}\n```\n\n#### 4.2 ToolBus Integration\n**File**: `crates/locus_toolbus/src/mcp/toolbus_integration.rs`\n\n```rust\npub struct McpToolWrapper {\n    server_id: String,\n    tool: Tool,\n    manager: Arc<McpManager>,\n}\n\n#[async_trait]\nimpl Tool for McpToolWrapper {\n    fn name(&self) -> &str {\n        // Format: mcp.{server_id}.{tool_name}\n        &self.tool.name\n    }\n\n    fn description(&self) -> &str {\n        &self.tool.description\n    }\n\n    fn parameters_schema(&self) -> &serde_json::Value {\n        &self.tool.input_schema\n    }\n\n    async fn call(&self, args: serde_json::Value) -> Result<serde_json::Value> {\n        self.manager.call_tool(&self.server_id, &self.tool.name, args).await\n    }\n}\n```\n\n### Phase 5: Error Handling\n\n**File**: `crates/locus_toolbus/src/mcp/error.rs`\n\n```rust\n#[derive(Debug, thiserror::Error)]\npub enum McpError {\n    #[error(\"Server not found: {0}\")]\n    ServerNotFound(String),\n\n    #[error(\"Server already running: {0}\")]\n    ServerAlreadyRunning(String),\n\n    #[error(\"Server not running: {0}\")]\n    ServerNotRunning(String),\n\n    #[error(\"Failed to start server: {0}\")]\n    StartFailed(String),\n\n    #[error(\"JSON-RPC error: {0}\")]\n    JsonRpc(String),\n\n    #[error(\"Protocol error: {0}\")]\n    Protocol(String),\n\n    #[error(\"Authentication failed: {0}\")]\n    AuthFailed(String),\n\n    #[error(\"Tool not found: {0}\")]\n    ToolNotFound(String),\n\n    #[error(\"Configuration error: {0}\")]\n    Config(String),\n\n    #[error(\"IO error: {0}\")]\n    Io(#[from] std::io::Error),\n}\n```\n\n## CLI Usage Examples\n\n### Adding MCP Servers\n\n```bash\n# Add a simple MCP server (no auth)\nlocus mcp add \\\n  --id filesystem \\\n  --name \"Filesystem Server\" \\\n  --command mcp-filesystem \\\n  --args \"--root\" --args \"/home/user/projects\" \\\n  --auto-start\n\n# Add MCP server with authentication\nlocus mcp add \\\n  --id github \\\n  --name \"GitHub Server\" \\\n  --command mcp-github \\\n  --args \"--repo\" --args \"owner/repo\" \\\n  --auth-type bearer \\\n  --auth-token \"$GITHUB_TOKEN\" \\\n  --auto-start\n\n# Add with environment variables\nlocus mcp add \\\n  --id database \\\n  --name \"PostgreSQL Server\" \\\n  --command mcp-postgres \\\n  --env \"DATABASE_URL=postgresql://localhost/mydb\" \\\n  --auto-start\n```\n\n### Managing Servers\n\n```bash\nlocus mcp list\nlocus mcp list --detailed\nlocus mcp info filesystem\nlocus mcp test github\nlocus mcp start database\nlocus mcp stop filesystem\nlocus mcp remove old-server\n```\n\n### Using MCP Tools\n\n```bash\nlocus mcp call filesystem.read_file --args '{\"path\": \"/home/user/file.txt\"}'\nlocus toolbus call mcp.filesystem_read_file --args '{\"path\": \"/home/user/file.txt\"}'\n```\n\n## File Structure\n\n```\ncrates/locus_toolbus/src/mcp/\n├── mod.rs              # Module exports\n├── plan.md             # This plan\n├── protocol.rs         # MCP JSON-RPC types\n├── client.rs           # MCP client implementation\n├── config.rs           # Server configuration types\n├── manager.rs          # Server registry and lifecycle\n├── error.rs            # Error types\n└── toolbus_integration.rs  # ToolBus adapter\n```\n\n## Dependencies\n\nAdd to `crates/locus_toolbus/Cargo.toml`:\n\n```toml\n[dependencies]\ntokio = { version = \"1\", features = [\"process\", \"io-util\", \"time\"] }\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\ntoml = \"0.8\"\nthiserror = \"1\"\ntracing = \"0.1\"\nasync-trait = \"0.1\"\n```\n\n## Security Considerations\n\n1. **Token Storage**: Store auth tokens securely (consider OS keychain integration)\n2. **Process Isolation**: Run MCP servers with minimal permissions\n3. **Input Validation**: Validate all tool inputs before passing to MCP servers\n4. **Rate Limiting**: Implement rate limiting for tool calls\n5. **Audit Logging**: Log all MCP tool invocations for security auditing\n"}
